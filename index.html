<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Block Blast - –¢–æ—á–Ω–∞—è –∫–æ–ø–∏—è (HTML)</title>
<style>
  :root{
    --cell-size:35px;
    --grid-gap:2px;
    --bg1:#1a1a2e;
    --bg2:#16213e;
    --panel-bg: rgba(0,0,0,0.25);
    --cell-bg:#191919;
    --cell-border:#3c3c3c;
    --highlight-bg: rgba(100,200,100,0.25);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  body{
    background: linear-gradient(135deg,var(--bg1),var(--bg2));
    display:flex;align-items:center;justify-content:center;padding:20px;
    color:#fff;
  }
  .app{
    width:800px; max-width:calc(100% - 40px);
    background:transparent;
    display:grid;
    grid-template-columns: 1fr 280px;
    gap:20px;
  }

  /* Left: board + top */
  .left{
    display:flex;flex-direction:column;gap:16px;
  }

  .topbar{
    display:flex;align-items:center;gap:12px;
  }
  .score{
    padding:10px;border-radius:10px;background:var(--panel-bg);font-weight:700;
    min-width:170px;
  }
  .controls{margin-left:auto;display:flex;gap:8px;align-items:center;}
  button{
    background:#4CAF50;border:none;color:white;padding:10px 14px;border-radius:8px;font-weight:700;
    cursor:pointer;
  }
  button:hover{filter:brightness(.95)}
  button:active{filter:brightness(.9)}

  /* Board */
  .board-wrap{
    padding:10px;border-radius:12px;background:rgba(0,0,0,0.08);
    display:flex;justify-content:center;
  }
  .grid{
    background:transparent;
    display:grid;
    grid-template-columns: repeat(9, var(--cell-size));
    grid-template-rows: repeat(9, var(--cell-size));
    gap: var(--grid-gap);
    padding:10px;
    border-radius:8px;
  }
  .cell{
    width:var(--cell-size);height:var(--cell-size);
    background:var(--cell-bg);border-radius:6px;border:1px solid var(--cell-border);
    box-sizing:border-box;position:relative;user-select:none;
    display:flex;align-items:center;justify-content:center;
  }
  .cell.filled{box-shadow:inset 0 0 0 2px rgba(0,0,0,0.2);}
  .cell .shine{position:absolute;top:4px;left:4px;right:4px;height:8px;border-radius:3px;opacity:.25;}
  .cell.highlight{outline:2px solid rgba(100,255,100,.9);background:var(--highlight-bg);}

  /* Right panel */
  .panel{
    padding:16px;border-radius:12px;background:rgba(0,0,0,0.12);height:100%;
    display:flex;flex-direction:column;gap:12px;
  }
  .previews{
    display:flex;flex-direction:column;gap:10px;align-items:center;
  }
  .preview{
    width:120px;height:120px;border-radius:10px;background:#2d2d2d;display:flex;align-items:center;justify-content:center;
    position:relative;cursor:grab;user-select:none;border:2px solid rgba(255,255,255,0.03);
  }
  .preview.unavailable{opacity:.35;cursor:default}
  .figure-block{
    position:absolute;box-sizing:border-box;border-radius:3px;border:1px solid rgba(0,0,0,.2);
  }
  .preview.selected{box-shadow:0 0 0 3px rgba(100,200,100,.15);}

  .meta{display:flex;flex-direction:column;gap:8px;align-items:stretch}
  .label{color:#dcdcdc;font-size:13px}
  .hint{font-size:12px;color:#bfbfbf}

  .small{
    font-size:12px;padding:8px;border-radius:8px;background:rgba(0,0,0,0.12);text-align:center;
  }
</style>
</head>
<body>
  <div class="app" id="app">
    <div class="left">
      <div class="topbar">
        <div class="score" id="score-display">–°—á–µ—Ç: 0<br>–†–µ–∫–æ—Ä–¥: 0</div>
        <div class="controls">
          <button id="btn-new">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
          <button id="btn-clear">–û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
      </div>

      <div class="board-wrap">
        <div class="grid" id="grid" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ 9 –Ω–∞ 9"></div>
      </div>
    </div>

    <aside class="panel">
      <div class="meta">
        <div class="label">–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã</div>
        <div class="hint">–ü–µ—Ä–µ—Ç—è–Ω–∏—Ç–µ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ —Ñ–∏–≥—É—Ä—É, –∑–∞—Ç–µ–º –∫–ª–∏–∫–Ω–∏—Ç–µ –∫–ª–µ—Ç–∫—É –Ω–∞ –ø–æ–ª–µ</div>
      </div>

      <div class="previews" id="previews"></div>

      <div class="small" id="status">–•–æ–¥–∏—Ç–µ</div>
      <div style="flex:1"></div>
      <div style="font-size:12px;color:#cfcfcf">–°–¥–µ–ª–∞–Ω–æ –≤ HTML/JS ‚Äî —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è PyQt –∏–≥—Ä—ã</div>
    </aside>
  </div>

<script>
(() => {
  /* ====== Shapes and utilities ====== */
  const SHAPES = {
    single: [[0,0]],
    line2_h: [[0,0],[0,1]],
    line2_v: [[0,0],[1,0]],
    line3_h: [[0,0],[0,1],[0,2]],
    line3_v: [[0,0],[1,0],[2,0]],
    line4_h: [[0,0],[0,1],[0,2],[0,3]],
    line4_v: [[0,0],[1,0],[2,0],[3,0]],
    line5_h: [[0,0],[0,1],[0,2],[0,3],[0,4]],
    line5_v: [[0,0],[1,0],[2,0],[3,0],[4,0]],
    square2x2: [[0,0],[0,1],[1,0],[1,1]],
    square3x3: [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],
    L_shape: [[0,0],[1,0],[2,0],[2,1]],
    L_mirror: [[0,0],[1,0],[2,0],[2,-1]],
    L_rotated: [[0,0],[0,1],[0,2],[1,0]],
    L_rotated_mirror: [[0,0],[0,1],[0,2],[-1,0]],
    T_shape: [[0,0],[0,1],[0,2],[1,1]],
    T_upside: [[0,1],[1,0],[1,1],[1,2]],
    T_left: [[0,0],[1,0],[2,0],[1,-1]],
    T_right: [[0,0],[1,0],[2,0],[1,1]],
    corner_small: [[0,0],[0,1],[1,0]],
    corner_big: [[0,0],[0,1],[0,2],[1,0],[2,0]],
    Z_shape: [[0,0],[0,1],[1,1],[1,2]],
    Z_mirror: [[0,1],[0,2],[1,0],[1,1]]
  };

  const COLORS = [
    '#FF5757','#57A5FF','#57FF57','#FFCE57','#FF57FF','#57FFFF','#FFA557','#A557FF'
  ];

  const GRID_SIZE = 9;
  const CELL_SIZE = 35; // used for rendering in previews
  const previewsCount = 3;

  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function shapeBounding(blocks){
    let minR=Infinity,maxR=-Infinity,minC=Infinity,maxC=-Infinity;
    for(const [r,c] of blocks){ minR=Math.min(minR,r); maxR=Math.max(maxR,r); minC=Math.min(minC,c); maxC=Math.max(maxC,c); }
    return {minR,maxR,minC,maxC,width:maxC-minC+1,height:maxR-minR+1};
  }

  /* ====== Game state ====== */
  let grid = []; // {filled:boolean, color:string, el:DOM}
  let figures = []; // {shapeName, blocks, color, isPlaced}
  let selectedFigureIndex = null;
  let score = 0;
  const HS_KEY = 'block_blast_high_score_v1';
  let highScore = parseInt(localStorage.getItem(HS_KEY) || '0',10) || 0;

  /* ====== DOM refs ====== */
  const gridEl = document.getElementById('grid');
  const previewsEl = document.getElementById('previews');
  const scoreDisplay = document.getElementById('score-display');
  const statusEl = document.getElementById('status');
  const btnNew = document.getElementById('btn-new');
  const btnClear = document.getElementById('btn-clear');

  /* ====== Init functions ====== */
  function makeGrid(){
    gridEl.innerHTML = '';
    grid = [];
    for(let r=0;r<GRID_SIZE;r++){
      for(let c=0;c<GRID_SIZE;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r; cell.dataset.c = c;
        cell.style.width = `${CELL_SIZE}px`; cell.style.height = `${CELL_SIZE}px`;
        cell.addEventListener('click', onCellClick);
        cell.addEventListener('dragover', ev=>ev.preventDefault());
        cell.addEventListener('dragenter', ev=>onCellDragEnter(ev, r, c));
        cell.addEventListener('dragleave', ev=>onCellDragLeave(ev, r, c));
        cell.addEventListener('drop', ev=>onCellDrop(ev, r, c));
        const shine = document.createElement('div');
        shine.className = 'shine';
        cell.appendChild(shine);
        gridEl.appendChild(cell);
        grid.push({filled:false,color:null,el:cell});
      }
    }
  }

  function makeRandomFigure(){
    const keys = Object.keys(SHAPES);
    const name = randChoice(keys);
    const blocks = SHAPES[name].map(([r,c])=>[r,c]);
    const color = randChoice(COLORS);
    return {shapeName:name,blocks,color,isPlaced:false};
  }

  function spawnFigures(){
    figures = [];
    for(let i=0;i<previewsCount;i++) figures.push(makeRandomFigure());
    selectedFigureIndex = null;
    renderPreviews();
    updateStatus('–•–æ–¥–∏—Ç–µ');
  }

  function startNewGame(){
    score = 0; updateScore(0);
    makeGrid();
    spawnFigures();
    renderBoard();
  }

  /* ====== Rendering ====== */
  function renderBoard(){
    // apply cell colors
    for(let r=0;r<GRID_SIZE;r++){
      for(let c=0;c<GRID_SIZE;c++){
        const idx = r*GRID_SIZE + c;
        const cellObj = grid[idx];
        const el = cellObj.el;
        el.classList.toggle('filled', cellObj.filled);
        el.style.background = cellObj.filled ? cellObj.color : 'var(--cell-bg)';
        el.querySelector('.shine').style.background = cellObj.filled ? 'rgba(255,255,255,0.12)' : 'transparent';
      }
    }
  }

  function renderPreviews(){
    previewsEl.innerHTML = '';
    figures.forEach((fig,i)=>{
      const p = document.createElement('div');
      p.className = 'preview';
      if(fig.isPlaced) p.classList.add('unavailable');
      if(selectedFigureIndex===i) p.classList.add('selected');
      p.draggable = !fig.isPlaced;
      p.dataset.idx = i;
      p.addEventListener('mousedown', ev=>onPreviewMouseDown(ev,i));
      p.addEventListener('dragstart', ev=>onPreviewDragStart(ev,i));
      // draw blocks inside preview
      const b = shapeBounding(fig.blocks);
      const scale = 20; // block size inside preview
      const offsetX = Math.floor((120 - b.width*scale)/2) - b.minC*scale;
      const offsetY = Math.floor((120 - b.height*scale)/2) - b.minR*scale;
      fig.blocks.forEach(([r,c])=>{
        const block = document.createElement('div');
        block.className = 'figure-block';
        block.style.left = `${offsetX + c*scale}px`;
        block.style.top = `${offsetY + r*scale}px`;
        block.style.width = `${scale-4}px`;
        block.style.height = `${scale-4}px`;
        block.style.background = fig.color;
        block.style.boxShadow = 'inset 0 -6px 18px rgba(0,0,0,0.25)';
        p.appendChild(block);
      });
      p.addEventListener('click', ()=> {
        if(fig.isPlaced) return;
        // toggle selection
        if(selectedFigureIndex === i) selectedFigureIndex = null;
        else selectedFigureIndex = i;
        renderPreviews();
      });
      previewsEl.appendChild(p);
    });
  }

  /* ====== Placement logic ====== */
  function indexOf(r,c){ return r*GRID_SIZE + c; }

  function canPlace(fig, baseR, baseC){
    if(!fig || fig.isPlaced) return false;
    for(const [dr,dc] of fig.blocks){
      const nr = baseR + dr, nc = baseC + dc;
      if(nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE) return false;
      if(grid[indexOf(nr,nc)].filled) return false;
    }
    return true;
  }

  function setPreviewHighlight(fig, baseR, baseC){
    // clear previous
    clearHighlights();
    if(!fig) return;
    if(!canPlace(fig, baseR, baseC)) return;
    for(const [dr,dc] of fig.blocks){
      const nr = baseR + dr, nc = baseC + dc;
      const idx = indexOf(nr,nc);
      grid[idx].el.classList.add('highlight');
    }
  }

  function clearHighlights(){
    grid.forEach(cell=> cell.el.classList.remove('highlight'));
  }

  function placeFigure(figIdx, baseR, baseC){
    const fig = figures[figIdx];
    if(!fig || fig.isPlaced) return false;
    if(!canPlace(fig, baseR, baseC)) return false;
    // place
    for(const [dr,dc] of fig.blocks){
      const nr = baseR + dr, nc = baseC + dc, idx = indexOf(nr,nc);
      grid[idx].filled = true;
      grid[idx].color = fig.color;
    }
    fig.isPlaced = true;
    selectedFigureIndex = null;
    renderBoard(); renderPreviews();
    // score points: number of blocks
    const points = fig.blocks.length;
    updateScore(points);
    // check lines
    const cleared = checkAndClearLines();
    if(cleared>0) updateScore(cleared*10);
    // if all previews placed -> refill
    if(figures.every(f=>f.isPlaced)) {
      figures = figures.map(_=>makeRandomFigure());
      renderPreviews();
    }
    // check game over: if no figure can be placed anywhere --> game over
    if(!canPlaceAnyFigure()){
      updateStatus('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞');
      setTimeout(()=> {
        if(confirm('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞. –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ?')) startNewGame();
      }, 50);
    }
    return true;
  }

  function canPlaceAnyFigure(){
    for(const fig of figures){
      if(fig.isPlaced) continue;
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          if(canPlace(fig,r,c)) return true;
        }
      }
    }
    return false;
  }

  /* ====== Line clearing ====== */
  function checkAndClearLines(){
    const rowsToClear = [];
    const colsToClear = [];
    for(let r=0;r<GRID_SIZE;r++){
      let full = true;
      for(let c=0;c<GRID_SIZE;c++){
        if(!grid[indexOf(r,c)].filled){ full=false; break; }
      }
      if(full) rowsToClear.push(r);
    }
    for(let c=0;c<GRID_SIZE;c++){
      let full = true;
      for(let r=0;r<GRID_SIZE;r++){
        if(!grid[indexOf(r,c)].filled){ full=false; break; }
      }
      if(full) colsToClear.push(c);
    }

    if(rowsToClear.length===0 && colsToClear.length===0) return 0;

    // animate blink then clear
    const toClearIdxs = new Set();
    rowsToClear.forEach(r=>{
      for(let c=0;c<GRID_SIZE;c++) toClearIdxs.add(indexOf(r,c));
    });
    colsToClear.forEach(c=>{
      for(let r=0;r<GRID_SIZE;r++) toClearIdxs.add(indexOf(r,c));
    });
    const arr = Array.from(toClearIdxs);
    // blink effect
    let blink = 0;
    const interval = setInterval(()=>{
      blink++;
      arr.forEach(i=>{
        grid[i].el.style.visibility = (blink%2===0) ? 'hidden' : 'visible';
      });
      if(blink>3){
        clearInterval(interval);
        // clear permanently
        arr.forEach(i=>{
          grid[i].filled=false; grid[i].color=null; grid[i].el.style.visibility='visible';
        });
        renderBoard();
      }
    }, 120);

    // points: number of lines cleared
    const linesCleared = rowsToClear.length + colsToClear.length;
    return linesCleared;
  }

  /* ====== Score ====== */
  function updateScore(delta){
    if(delta!==0) score += delta;
    if(score > highScore){ highScore = score; localStorage.setItem(HS_KEY, String(highScore)); }
    scoreDisplay.innerHTML = `–°—á–µ—Ç: ${score}<br>–†–µ–∫–æ—Ä–¥: ${highScore}`;
    // small flash
    scoreDisplay.style.background = 'rgba(100,200,100,0.45)';
    setTimeout(()=> scoreDisplay.style.background = 'var(--panel-bg)', 250);
  }

  function updateStatus(text){
    statusEl.textContent = text;
  }

  /* ====== Event handlers ====== */
  function onCellClick(e){
    const r = parseInt(this.dataset.r,10);
    const c = parseInt(this.dataset.c,10);
    clearHighlights();
    if(selectedFigureIndex !== null){
      // try place selected
      if(placeFigure(selectedFigureIndex, r, c)){
        updateStatus('–§–∏–≥—É—Ä–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∞');
      } else {
        updateStatus('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å');
        setTimeout(()=>updateStatus('–•–æ–¥–∏—Ç–µ'),700);
      }
    } else {
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É —Å–ª–µ–≤–∞');
      setTimeout(()=>updateStatus('–•–æ–¥–∏—Ç–µ'),700);
    }
  }

  function onCellDragEnter(ev, r, c){
    ev.preventDefault();
    // the dragged data has a 'figureIdx'
    const txt = ev.dataTransfer.getData('text/plain');
    if(!txt) return;
    const parsed = txt.split(':');
    if(parsed[0] !== 'figure') return;
    const idx = Number(parsed[1]);
    if(isNaN(idx)) return;
    setPreviewHighlight(figures[idx], r, c);
  }

  function onCellDragLeave(ev, r, c){
    clearHighlights();
  }

  function onCellDrop(ev, r, c){
    ev.preventDefault();
    clearHighlights();
    const txt = ev.dataTransfer.getData('text/plain');
    if(!txt) return;
    const parsed = txt.split(':');
    if(parsed[0] !== 'figure') return;
    const idx = Number(parsed[1]);
    if(isNaN(idx)) return;
    placeFigure(idx, r, c);
  }

  function onPreviewMouseDown(ev, idx){
    // left click handled as selection in click listener (renderPreviews added a click handler).
    // but we want to deselect if right click
    if(ev.button === 2) {
      ev.preventDefault();
      // cancel selection
      if(selectedFigureIndex === idx) selectedFigureIndex = null;
      renderPreviews();
    }
  }

  function onPreviewDragStart(ev, idx){
    const fig = figures[idx];
    if(!fig || fig.isPlaced) { ev.preventDefault(); return; }
    // attach text payload
    ev.dataTransfer.setData('text/plain', `figure:${idx}`);
    // create drag image (canvas)
    const cvs = document.createElement('canvas');
    cvs.width = 120; cvs.height = 120;
    const ctx = cvs.getContext('2d');
    // draw bg transparent
    ctx.clearRect(0,0,cvs.width,cvs.height);
    const b = shapeBounding(fig.blocks);
    const scale = 20;
    const offsetX = Math.floor((120 - b.width*scale)/2) - b.minC*scale;
    const offsetY = Math.floor((120 - b.height*scale)/2) - b.minR*scale;
    fig.blocks.forEach(([r,c])=>{
      ctx.fillStyle = fig.color;
      ctx.fillRect(offsetX + c*scale + 2, offsetY + r*scale + 2, scale-4, scale-4);
    });
    ev.dataTransfer.setDragImage(cvs, ev.offsetX, ev.offsetY);
  }

  /* ====== Controls ====== */
  btnNew.addEventListener('click', ()=> {
    if(confirm('–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É?')) startNewGame();
  });
  btnClear.addEventListener('click', ()=> {
    if(confirm('–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ?')) {
      makeGrid();
      renderBoard();
      updateStatus('–ü–æ–ª–µ –æ—á–∏—â–µ–Ω–æ');
      setTimeout(()=>updateStatus('–•–æ–¥–∏—Ç–µ'),600);
    }
  });

  /* ====== Initialization run ====== */
  makeGrid();
  spawnFigures();
  renderBoard();
  renderPreviews();
  scoreDisplay.innerHTML = `–°—á–µ—Ç: ${score}<br>–†–µ–∫–æ—Ä–¥: ${highScore}`;

  /* ====== Expose helpers for cells to access coords (closure-friendly) ====== */
  // attach click handling dynamically (delegation not used to keep direct references)
  const cells = gridEl.querySelectorAll('.cell');
  cells.forEach(cell => cell.addEventListener('mousemove', function(ev){
    // show preview if a figure is selected
    const r = parseInt(this.dataset.r,10), c = parseInt(this.dataset.c,10);
    clearHighlights();
    if(selectedFigureIndex !== null){
      setPreviewHighlight(figures[selectedFigureIndex], r, c);
    }
  }));

  // allow clicking an empty space to unselect
  document.addEventListener('click', (e)=>{
    if(!e.target.closest('.preview')) {
      selectedFigureIndex = null;
      renderPreviews();
      clearHighlights();
    }
  });

  // expose drop on grid general area (if drop between cells)
  gridEl.addEventListener('dragover', ev=>ev.preventDefault());
  gridEl.addEventListener('drop', ev=>{
    ev.preventDefault();
    // compute cell from mouse position
    const rect = gridEl.getBoundingClientRect();
    const x = ev.clientX - rect.left - 10; // account grid padding
    const y = ev.clientY - rect.top - 10;
    const col = Math.floor(x / (CELL_SIZE + parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'))));
    const row = Math.floor(y / (CELL_SIZE + parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'))));
    const txt = ev.dataTransfer.getData('text/plain');
    if(!txt) return;
    const parsed = txt.split(':');
    if(parsed[0] !== 'figure') return;
    const idx = Number(parsed[1]);
    if(isNaN(idx)) return;
    if(row>=0 && row<GRID_SIZE && col>=0 && col<GRID_SIZE){
      placeFigure(idx,row,col);
    }
  });

})();
</script>
</body>
</html>
