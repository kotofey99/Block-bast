<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Block Blast ‚ú®</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      min-height: 100vh;
    }
    h1 {
      margin: 10px 0;
      font-size: 1.8rem;
      text-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }
    .stats {
      display: flex;
      gap: 20px;
      margin: 10px 0;
      font-size: 1.2rem;
      background: rgba(0,0,0,0.3);
      padding: 8px 16px;
      border-radius: 8px;
    }
    .board {
      display: grid;
      gap: 2px;
      background: #1e1e3f;
      padding: 6px;
      margin: 12px auto;
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    .cell {
      width: 42px;
      height: 42px;
      background: #2d2d5f;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s ease;
      position: relative;
    }
    .cell::after {
      content: '';
      position: absolute;
      inset: 4px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    .cell.filled {
      background: #6a11cb;
      box-shadow: inset 0 0 8px rgba(255,255,255,0.2);
    }
    .cell.clearing {
      animation: fadeOutScale 0.4s forwards;
    }
    @keyframes fadeOutScale {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }
    .preview-area {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin: 16px 0;
      flex-wrap: wrap;
    }
    .piece {
      display: grid;
      gap: 2px;
      padding: 6px;
      background: #2a2a5a;
      border-radius: 8px;
      cursor: grab;
      transition: transform 0.2s;
      animation: fadeIn 0.5s ease-out;
      position: relative;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .piece.shake {
      animation: shake 0.5s;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-6px); }
      40%, 80% { transform: translateX(6px); }
    }
    .piece-cell {
      width: 22px;
      height: 22px;
      background: #8e2de2;
      border-radius: 5px;
      box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
    }
    button {
      background: linear-gradient(to right, #6a11cb, #2575fc);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 50px;
      font-size: 1.05rem;
      cursor: pointer;
      margin: 6px;
      transition: all 0.3s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0,0,0,0.4);
    }
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s;
    }
    .modal.active {
      opacity: 1;
      pointer-events: all;
    }
    .modal-content {
      background: rgba(30,30,60,0.95);
      padding: 24px;
      border-radius: 16px;
      text-align: center;
      max-width: 90%;
      width: 320px;
      border: 1px solid #5a5a9a;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
  </style>
</head>
<body>
  <h1>Block Blast üßä</h1>
  <div class="stats">
    <div>–°—á—ë—Ç: <span id="score">0</span></div>
    <div>–†–µ–∫–æ—Ä–¥: <span id="highscore">0</span></div>
  </div>

  <div class="board" id="board"></div>

  <div class="preview-area" id="preview-area"></div>

  <div class="controls">
    <button id="new-game">üîÅ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    <button id="settings-btn">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
  </div>

  <div class="modal" id="settings-modal">
    <div class="modal-content">
      <h3 style="margin-bottom:16px">üéÆ –°–ª–æ–∂–Ω–æ—Å—Ç—å</h3>
      <div class="difficulty">
        <button data-diff="5">–õ—ë–≥–∫–∏–π (5√ó5)</button><br>
        <button data-diff="6">–°—Ä–µ–¥–Ω–∏–π (6√ó6)</button><br>
        <button data-diff="7">–°–ª–æ–∂–Ω—ã–π (7√ó7)</button>
      </div>
      <button id="close-settings" style="margin-top: 20px;">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

<script>

const PIECES = [
  [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]],
  [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]],
  [[1,1],[1,0]], [[1,1],[0,1]], [[1,0],[1,1]], [[0,1],[1,1]],
  [[1,1,1],[0,1,0]], [[1,0],[1,1],[1,0]], [[0,1],[1,1],[0,1]], [[1,1],[0,1],[0,1]],
  [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]],
  [[1,0],[1,1],[0,1]], [[0,1],[1,1],[1,0]],
  [[1,1],[1,1]],
  [[1,1,1],[1,1,0]], [[1,1,0],[1,1,1]],
  [[1,1],[1,1],[1,0]], [[1,0],[1,1],[1,1]],
  [[1,0,0],[1,1,0],[0,1,0]], [[0,0,1],[0,1,1],[0,1,0]],
  [[1,1,0],[0,1,1],[0,0,1]], [[0,1,1],[1,1,0],[1,0,0]],
  [[0,1,0],[1,1,1],[0,1,0]],
  [[1,1],[1,1],[1,0]], [[1,1],[1,1],[0,1]],
  [[1,1,1],[1,0,1]],
  [[1,0,1],[0,1,0],[1,0,1]],
  [[1,1,0,0],[0,1,1,0]],
  [[1,0,0],[1,1,0],[0,1,1]],
  [[0,1,0],[1,1,1],[1,0,1]],
];

let boardSize = 5;
let board = [];
let previewPieces = [];
let score = 0;

let isDragging = false;
let draggedPiece = null;
let draggedOffset = {x:0,y:0};

let highscore = parseInt(localStorage.getItem('blockblast_highscore')) || 0;

const boardEl = document.getElementById("board");
const previewEl = document.getElementById("preview-area");
const scoreEl = document.getElementById("score");
const highscoreEl = document.getElementById("highscore");

highscoreEl.textContent = highscore;

initGame();

// =====================
// INIT
// =====================

function initGame() {
  createBoard();
  generatePreviewPieces();
  renderBoard();
  renderPreview();
  score = 0;
  scoreEl.textContent = score;
}

function createBoard() {
  board = Array(boardSize).fill().map(()=>Array(boardSize).fill(0));
}

function generatePreviewPieces() {
  previewPieces = [];
  for (let i=0;i<3;i++) {
    const idx = Math.floor(Math.random()*PIECES.length);
    previewPieces.push(JSON.parse(JSON.stringify(PIECES[idx])));
  }
}

function renderBoard() {
  boardEl.innerHTML = "";
  boardEl.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;

  for (let r=0;r<boardSize;r++) {
    for (let c=0;c<boardSize;c++) {
      const cell=document.createElement("div");
      cell.className="cell";
      if (board[r][c]) cell.classList.add("filled");
      cell.dataset.row=r;
      cell.dataset.col=c;
      boardEl.appendChild(cell);
    }
  }
}

function renderPreview() {
  previewEl.innerHTML="";

  previewPieces.forEach((piece,idx)=>{
    const pieceEl=document.createElement("div");
    pieceEl.className="piece";
    pieceEl.dataset.idx = idx;
    pieceEl.style.gridTemplateColumns = `repeat(${piece[0].length}, 1fr)`;

    for (let r=0;r<piece.length;r++){
      for (let c=0;c<piece[r].length;c++){
        const cell=document.createElement("div");
        if (piece[r][c]) cell.className="piece-cell";
        pieceEl.appendChild(cell);
      }
    }

    pieceEl.addEventListener("mousedown", startDrag);
    pieceEl.addEventListener("touchstart", startDrag, {passive:false});

    previewEl.appendChild(pieceEl);
  });
}

// ===============================
// FIXED DRAG & DROP SYSTEM
// ===============================

function startDrag(e){
  e.preventDefault();
  isDragging = true;
  draggedPiece = e.currentTarget;

  const rect = draggedPiece.getBoundingClientRect();

  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  draggedOffset.x = clientX - rect.left;
  draggedOffset.y = clientY - rect.top;

  draggedPiece.style.position = "absolute";
  draggedPiece.style.left = rect.left + "px";
  draggedPiece.style.top = rect.top + "px";
  draggedPiece.style.transform = "none";
  draggedPiece.style.opacity = "0.8";
  draggedPiece.style.zIndex = "1000";

  document.body.appendChild(draggedPiece);

  document.addEventListener("mousemove", drag);
  document.addEventListener("touchmove", drag, {passive:false});
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("touchend", endDrag);
}

function drag(e){
  if (!isDragging) return;

  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  draggedPiece.style.left = clientX - draggedOffset.x + "px";
  draggedPiece.style.top = clientY - draggedOffset.y + "px";
}

function endDrag(e){
  if (!isDragging) return;
  isDragging=false;

  draggedPiece.style.opacity="1";

  const pieceRect = draggedPiece.getBoundingClientRect();
  const centerX = pieceRect.left + pieceRect.width/2;
  const centerY = pieceRect.top + pieceRect.height/2;

  const boardRect = boardEl.getBoundingClientRect();

  let placed = false;

  if (
    centerX >= boardRect.left &&
    centerX <= boardRect.right &&
    centerY >= boardRect.top &&
    centerY <= boardRect.bottom
  ) {
    const cellSize = boardRect.width / boardSize;
    const col = Math.floor((centerX - boardRect.left)/cellSize);
    const row = Math.floor((centerY - boardRect.top)/cellSize);

    const idx = parseInt(draggedPiece.dataset.idx);

    if (canPlace(previewPieces[idx], row, col)) {
      placePiece(idx, row, col);
      placed = true;
    }
  }

  if (!placed){
    draggedPiece.classList.add("shake");
    setTimeout(()=>draggedPiece?.classList.remove("shake"),500);
  }

  draggedPiece.style.position="";
  draggedPiece.style.left="";
  draggedPiece.style.top="";
  draggedPiece.style.zIndex="";

  draggedPiece=null;

  renderPreview();

  document.removeEventListener("mousemove", drag);
  document.removeEventListener("touchmove", drag);
  document.removeEventListener("mouseup", endDrag);
  document.removeEventListener("touchend", endDrag);
}

// =========================
// GAME LOGIC
// =========================

function canPlace(piece,row,col){
  for (let r=0;r<piece.length;r++){
    for (let c=0;c<piece[r].length;c++){
      if (!piece[r][c]) continue;

      const nr=row+r, nc=col+c;
      if (nr<0||nr>=boardSize||nc<0||nc>=boardSize) return false;
      if (board[nr][nc]===1) return false;
    }
  }
  return true;
}

function placePiece(pieceIdx,row,col){
  const piece = previewPieces[pieceIdx];

  for (let r=0;r<piece.length;r++){
    for (let c=0;c<piece[r].length;c++){
      if (piece[r][c]) board[row+r][col+c]=1;
    }
  }

  previewPieces.splice(pieceIdx,1);
  const newIdx=Math.floor(Math.random()*PIECES.length);
  previewPieces.push(JSON.parse(JSON.stringify(PIECES[newIdx])));

  renderBoard();
  setTimeout(()=>checkLines(),100);
  checkGameOver();
}

function checkLines(){
  const toClear=[];

  for (let r=0;r<boardSize;r++){
    if (board[r].every(c=>c===1)){
      for (let c=0;c<boardSize;c++) toClear.push({r,c});
    }
  }
  for (let c=0;c<boardSize;c++){
    let full=true;
    for (let r=0;r<boardSize;r++){
      if (board[r][c]!==1){ full=false; break; }
    }
    if (full){
      for (let r=0;r<boardSize;r++) toClear.push({r,c});
    }
  }

  if (toClear.length>0){
    score+=toClear.length*10;
    scoreEl.textContent=score;

    toClear.forEach(({r,c})=>{
      const cell=document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) cell.classList.add("clearing");
    });

    setTimeout(()=>{
      toClear.forEach(({r,c})=>board[r][c]=0);
      renderBoard();
    },400);
  }
}

function checkGameOver(){
  for (let piece of previewPieces){
    for (let r=0;r<boardSize;r++){
      for (let c=0;c<boardSize;c++){
        if (canPlace(piece,r,c)) return;
      }
    }
  }

  if (score>highscore){
    highscore=score;
    localStorage.setItem("blockblast_highscore",highscore);
    highscoreEl.textContent=highscore;
  }

  setTimeout(()=>alert("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í–∞—à —Å—á—ë—Ç: "+score),300);
}

// SETTINGS
document.getElementById("new-game").addEventListener("click", initGame);
document.getElementById("settings-btn").addEventListener("click", ()=>settingsModal.classList.add("active"));
document.getElementById("close-settings").addEventListener("click", ()=>settingsModal.classList.remove("active"));

document.querySelectorAll("[data-diff]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    boardSize=parseInt(btn.dataset.diff);
    settingsModal.classList.remove("active");
    initGame();
  });
});

document.body.addEventListener("touchmove",(e)=>{
  if (isDragging) e.preventDefault();
},{passive:false});

</script>
</body>
</html>
