<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Block Blast</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #1a1a2e;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      min-height: 100vh;
    }
    h1 {
      margin: 10px 0;
      font-size: 1.8rem;
    }
    .stats {
      display: flex;
      gap: 20px;
      margin: 10px 0;
      font-size: 1.2rem;
    }
    .board {
      display: grid;
      gap: 2px;
      background: #333;
      padding: 4px;
      margin: 10px auto;
      border-radius: 6px;
      overflow: hidden;
    }
    .cell {
      width: 40px;
      height: 40px;
      background: #222;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    .cell.filled {
      background: #4e54c8;
    }
    .preview-area {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin: 16px 0;
      flex-wrap: wrap;
    }
    .piece {
      display: grid;
      gap: 2px;
      padding: 4px;
      background: #333;
      border-radius: 6px;
      cursor: grab;
    }
    .piece-cell {
      width: 20px;
      height: 20px;
      background: #4e54c8;
      border-radius: 3px;
    }
    .controls {
      margin: 10px 0;
    }
    button {
      background: #4e54c8;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      margin: 4px;
    }
    button:hover {
      background: #6a71e6;
    }
    .settings {
      margin-top: 16px;
      text-align: center;
    }
    .difficulty {
      display: flex;
      gap: 8px;
      justify-content: center;
    }
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .modal.active {
      opacity: 1;
      pointer-events: all;
    }
    .modal-content {
      background: #2a2a4a;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      max-width: 90%;
      width: 300px;
    }
    @media (max-width: 500px) {
      .cell { width: 32px; height: 32px; }
      .piece-cell { width: 16px; height: 16px; }
    }
  </style>
</head>
<body>
  <h1>Block Blast</h1>
  <div class="stats">
    <div>Счёт: <span id="score">0</span></div>
    <div>Рекорд: <span id="highscore">0</span></div>
  </div>

  <div class="board" id="board"></div>

  <div class="preview-area" id="preview-area"></div>

  <div class="controls">
    <button id="new-game">Новая игра</button>
    <button id="settings-btn">Настройки</button>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settings-modal">
    <div class="modal-content">
      <h3>Сложность</h3>
      <div class="difficulty">
        <button data-diff="5">Лёгкий (5×5)</button>
        <button data-diff="6">Средний (6×6)</button>
        <button data-diff="7">Сложный (7×7)</button>
      </div>
      <button id="close-settings" style="margin-top: 16px;">Закрыть</button>
    </div>
  </div>

  <script>
    // Конфигурация
    const PIECES = [
      // Одноклеточные
      [[1]],
      // Двухклеточные
      [[1,1]],
      [[1],[1]],
      // Трёхклеточные
      [[1,1,1]],
      [[1],[1],[1]],
      [[1,1],[0,1]],
      [[1,1],[1,0]],
      [[1,0],[1,1]],
      [[0,1],[1,1]],
      // L-образные и др.
      [[1,0],[1,0],[1,1]],
      [[0,1],[0,1],[1,1]],
      [[1,1,1],[1,0,0]],
      [[1,1,1],[0,0,1]],
    ];

    // Состояние игры
    let boardSize = 5;
    let board = [];
    let previewPieces = [];
    let score = 0;
    let isDragging = false;
    let draggedPiece = null;
    let draggedOffset = { x: 0, y: 0 };
    let highscore = localStorage.getItem('blockblast_highscore') || 0;

    // DOM
    const boardEl = document.getElementById('board');
    const previewEl = document.getElementById('preview-area');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const newGameBtn = document.getElementById('new-game');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsBtn = document.getElementById('close-settings');

    // Инициализация
    highscoreEl.textContent = highscore;
    initGame();

    // === ФУНКЦИИ ===

    function initGame() {
      createBoard();
      generatePreviewPieces();
      renderBoard();
      renderPreview();
      score = 0;
      scoreEl.textContent = score;
    }

    function createBoard() {
      board = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
    }

    function generatePreviewPieces() {
      previewPieces = [];
      for (let i = 0; i < 3; i++) {
        const idx = Math.floor(Math.random() * PIECES.length);
        previewPieces.push(JSON.parse(JSON.stringify(PIECES[idx])));
      }
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      boardEl.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;

      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          if (board[r][c]) cell.classList.add('filled');
          boardEl.appendChild(cell);
        }
      }
    }

    function renderPreview() {
      previewEl.innerHTML = '';
      previewPieces.forEach((piece, idx) => {
        const pieceEl = document.createElement('div');
        pieceEl.className = 'piece';
        pieceEl.dataset.idx = idx;
        pieceEl.style.gridTemplateColumns = `repeat(${piece[0].length}, 1fr)`;
        pieceEl.style.gridTemplateRows = `repeat(${piece.length}, 1fr)`;

        for (let r = 0; r < piece.length; r++) {
          for (let c = 0; c < piece[r].length; c++) {
            if (piece[r][c]) {
              const cell = document.createElement('div');
              cell.className = 'piece-cell';
              pieceEl.appendChild(cell);
            } else {
              pieceEl.appendChild(document.createElement('div'));
            }
          }
        }

        // Drag events
        pieceEl.addEventListener('mousedown', startDrag);
        pieceEl.addEventListener('touchstart', startDrag, { passive: false });

        previewEl.appendChild(pieceEl);
      });
    }

    // === DRAG & DROP (мышь + touch) ===
    function startDrag(e) {
      e.preventDefault();
      isDragging = true;
      draggedPiece = e.currentTarget;
      const rect = draggedPiece.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      draggedOffset.x = clientX - rect.left;
      draggedOffset.y = clientY - rect.top;

      // Визуал
      draggedPiece.style.opacity = '0.6';
      draggedPiece.style.cursor = 'grabbing';

      document.addEventListener('mousemove', drag);
      document.addEventListener('touchmove', drag, { passive: false });
      document.addEventListener('mouseup', endDrag);
      document.addEventListener('touchend', endDrag);
    }

    function drag(e) {
      if (!isDragging) return;
      e.preventDefault();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      const x = clientX - draggedOffset.x;
      const y = clientY - draggedOffset.y;
      draggedPiece.style.transform = `translate(${x}px, ${y}px)`;
    }

    function endDrag(e) {
      if (!isDragging) return;
      isDragging = false;

      // Сброс стилей
      draggedPiece.style.opacity = '1';
      draggedPiece.style.transform = '';
      draggedPiece.style.cursor = 'grab';

      // Удаление обработчиков
      document.removeEventListener('mousemove', drag);
      document.removeEventListener('touchmove', drag);
      document.removeEventListener('mouseup', endDrag);
      document.removeEventListener('touchend', endDrag);

      // Попытка разместить
      const boardRect = boardEl.getBoundingClientRect();
      const pieceRect = draggedPiece.getBoundingClientRect();

      const centerX = pieceRect.left + pieceRect.width / 2;
      const centerY = pieceRect.top + pieceRect.height / 2;

      if (
        centerX >= boardRect.left &&
        centerX <= boardRect.right &&
        centerY >= boardRect.top &&
        centerY <= boardRect.bottom
      ) {
        // Преобразуем координаты в ячейку
        const cellSize = boardRect.width / boardSize;
        const col = Math.floor((centerX - boardRect.left) / cellSize);
        const row = Math.floor((centerY - boardRect.top) / cellSize);

        const idx = parseInt(draggedPiece.dataset.idx);
        placePiece(idx, row, col);
      }

      // Обновляем превью
      renderPreview();
    }

    // === ЛОГИКА ИГРЫ ===
    function placePiece(pieceIdx, row, col) {
      const piece = previewPieces[pieceIdx];
      if (!canPlace(piece, row, col)) return;

      // Устанавливаем
      for (let r = 0; r < piece.length; r++) {
        for (let c = 0; c < piece[r].length; c++) {
          if (piece[r][c]) {
            board[row + r][col + c] = 1;
          }
        }
      }

      // Удаляем использованную фигуру
      previewPieces.splice(pieceIdx, 1);
      // Добавляем новую
      const newIdx = Math.floor(Math.random() * PIECES.length);
      previewPieces.push(JSON.parse(JSON.stringify(PIECES[newIdx])));

      renderBoard();
      checkLines();
      checkGameOver();
    }

    function canPlace(piece, row, col) {
      for (let r = 0; r < piece.length; r++) {
        for (let c = 0; c < piece[r].length; c++) {
          if (!piece[r][c]) continue;
          const nr = row + r;
          const nc = col + c;
          if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) return false;
          if (board[nr][nc] === 1) return false;
        }
      }
      return true;
    }

    function checkLines() {
      let cleared = 0;

      // Проверка строк
      for (let r = 0; r < boardSize; r++) {
        if (board[r].every(cell => cell === 1)) {
          board[r] = Array(boardSize).fill(0);
          cleared++;
        }
      }

      // Проверка столбцов
      for (let c = 0; c < boardSize; c++) {
        let full = true;
        for (let r = 0; r < boardSize; r++) {
          if (board[r][c] !== 1) {
            full = false;
            break;
          }
        }
        if (full) {
          for (let r = 0; r < boardSize; r++) board[r][c] = 0;
          cleared++;
        }
      }

      // Проверка 3×3 квадратов (если размер >=3)
      if (boardSize >= 3) {
        for (let r = 0; r <= boardSize - 3; r++) {
          for (let c = 0; c <= boardSize - 3; c++) {
            let full = true;
            for (let dr = 0; dr < 3; dr++) {
              for (let dc = 0; dc < 3; dc++) {
                if (board[r + dr][c + dc] !== 1) {
                  full = false;
                  break;
                }
              }
              if (!full) break;
            }
            if (full) {
              for (let dr = 0; dr < 3; dr++) {
                for (let dc = 0; dc < 3; dc++) {
                  board[r + dr][c + dc] = 0;
                }
              }
              cleared++;
            }
          }
        }
      }

      if (cleared > 0) {
        score += cleared * 100;
        scoreEl.textContent = score;
      }
    }

    function checkGameOver() {
      // Проверяем, можно ли поставить хотя бы одну из фигур
      for (let pieceIdx = 0; pieceIdx < previewPieces.length; pieceIdx++) {
        const piece = previewPieces[pieceIdx];
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (canPlace(piece, r, c)) {
              return; // Есть куда поставить — игра не окончена
            }
          }
        }
      }

      // Конец игры
      if (score > highscore) {
        highscore = score;
        localStorage.setItem('blockblast_highscore', highscore);
        highscoreEl.textContent = highscore;
      }

      setTimeout(() => {
        alert(`Игра окончена!\nВаш счёт: ${score}`);
      }, 100);
    }

    // === ОБРАБОТЧИКИ ===
    newGameBtn.addEventListener('click', initGame);

    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('active');
    });

    closeSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.remove('active');
    });

    document.querySelectorAll('[data-diff]').forEach(btn => {
      btn.addEventListener('click', () => {
        boardSize = parseInt(btn.dataset.diff);
        settingsModal.classList.remove('active');
        initGame();
      });
    });

    // Запрет прокрутки при touchmove на драге (чтобы не дергалось)
    document.body.addEventListener('touchmove', e => {
      if (isDragging) e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>
